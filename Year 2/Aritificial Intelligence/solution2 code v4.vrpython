{"mode":"Text","textContent":"import random\n\nmyVariable = 0\nX2 = 0\nX3 = 0\nX1 = 0\nout1 = 0\nout2 = 0\n\n#weight arrays. 2 sets of weights for each direction\nForwardw1 = [0,0,0,0]\nForwardw2 = [0,0,0,0]\nLeftw1 = [0,0,0,0]\nLeftw2 = [0,0,0,0]\nRightw1 = [0,0,0,0]\nRightw2 = [0,0,0,0]\nReversew1 = [0,0,0,0]\nReversew2 = [0,0,0,0]\n\n\n#desired outputs\ndesoutForward = [1,1]\ndesoutLeft = [0,1]\ndesoutRight = [1,0]\ndesoutReverse = [0,0]\n\n\n#learning coefficient\nlc = 400\n\n\n#robot direction:\ndirection = \"forward\"\n\ndef initialWeightSetup():\n    global Forwardw1, Forwardw2, Leftw1, Leftw2, Rightw1, Rightw2, Reversew1, Reversew2\n    #randomly determine initial weights\n    for i in range(4):\n        Forwardw1[i] = random.randrange(-1,1)\n        Forwardw2[i] = random.randrange(-1,1)\n        Leftw1[i] = random.randrange(-1,1)\n        Leftw2[i] = random.randrange(-1,1)\n        Rightw1[i] = random.randrange(-1,1)\n        Rightw2[i] = random.randrange(-1,1)\n        Reversew1[i] = random.randrange(-1,1)\n        Reversew2[i] = random.randrange(-1,1)\n\ndef when_started1():\n    global myVariable, X2, X3, X1, out1, out2\n    while True:\n#First block that should stay the same\n        if distance.get_distance(MM) < 30:\n            X1 = 1\n        else:\n            X1 = 0\n        if left_bumper.pressed():\n            X2 = 1\n        else:\n            X2 = 0\n        if right_bumper.pressed():\n            X3 = 1\n        else:\n            X3 = 0\n#end of the first block that should stay the same\n\n\n\n##Change these\n        ## Determine direction robot is intending to travel\n\n        if(X1==0):\n            if(X2==0):\n                if(X3==0):\n                    direction = \"forward\"\n                else:\n                    direction = \"left\"\n            elif(X3==0):\n                direction = \"right\"\n            else:\n                direction = \"reverse\"\n        elif(X2==0):\n            if(X3==0):\n                direction = \"reverse\"\n            else:\n                direction = \"left\"\n        elif(X3==0):\n            direction = \"right\"\n        else:\n            direction = \"reverse\"\n\n\n        if(direction == \"forward\"):\n            net1=Forwardw1[1]*X1+Forwardw1[2]*X2+Forwardw1[3]*X3+Forwardw1[0]\n            net2=Forwardw2[1]*X1+Forwardw2[2]*X2+Forwardw2[3]*X3+Forwardw2[0]\n        elif(direction == \"left\"):\n            net1=Leftw1[1]*X1+Leftw1[2]*X2+Leftw1[3]*X3+Leftw1[0]\n            net2=Leftw2[1]*X1+Leftw2[2]*X2+Leftw2[3]*X3+Leftw2[0]\n        elif(direction == \"right\"):\n            net1=Rightw1[1]*X1+Rightw1[2]*X2+Rightw1[3]*X3+Rightw1[0]\n            net2=Rightw2[1]*X1+Rightw2[2]*X2+Rightw2[3]*X3+Rightw2[0]\n        elif(direction == \"reverse\"):\n            net1=Reversew1[1]*X1+Reversew1[2]*X2+Reversew1[3]*X3+Reversew1[0]\n            net2=Reversew2[1]*X1+Reversew2[2]*X2+Reversew2[3]*X3+Reversew2[0]\n\n            \n        if net1 >=0:\n            out1 = 1\n        else:\n            out1 = 0\n    \n        if net2 >=0:\n            out2 = 1\n        else:\n            out2 = 0\n        \n# this is the training data.\n        if(myVariable < 15000):\n            out1 = 1\n            out2 = 0\n            direction = \"right\"\n\n        if(myVariable < 10000):\n            out1 = 0\n            out2 = 1\n            direction = \"left\"\n\n        if(myVariable < 5000):\n            out1 = 1\n            out2 = 1\n            direction = \"forward\"\n        \n\n#for each desired output calculate the error \n        \n        \n        \n        for loop in range (2):\n            ForwardError1 = 0.5*((desoutForward[loop] - out1)^2)\n            ForwardError2 = 0.5*((desoutForward[loop] - out2)^2)\n            LeftError1 = 0.5*((desoutLeft[loop] - out1)^2)\n            LeftError2 = 0.5*((desoutLeft[loop] - out2)^2)\n            RightError1 = 0.5*((desoutLeft[loop] - out1)^2)\n            RightError2 = 0.5*((desoutRight[loop] - out2)^2)\n            ReverseError1 = 0.5*((desoutReverse[loop] - out1)^2)\n            ReverseError2 = 0.5*((desoutReverse[loop] - out2)^2)\n            \n\n            #use the error to calculate changes in weights and change weights\n\n            if(direction == \"forward\"):\n                deltaS1W0=lc*ForwardError1\n                Forwardw1[0]=Forwardw1[0]+deltaS1W0\n                \n                deltaS1W1=lc*ForwardError1*X1\n                Forwardw1[1]=Forwardw1[1]+deltaS1W1\n\n                deltaS1W2=lc*ForwardError1*X2\n                Forwardw1[2]=Forwardw1[2]+deltaS1W2\n\n                deltaS1W3=lc*ForwardError1*X3\n                Forwardw1[3]=Forwardw1[3]+deltaS1W3\n\n                deltaS2W0=lc*ForwardError2\n                Forwardw2[0]=Forwardw2[0]+deltaS2W0\n\n                deltaS2W1=lc*ForwardError2*X1\n                Forwardw2[1]=Forwardw2[1]+deltaS2W1\n\n                deltaS2W2=lc*ForwardError2*X2\n                Forwardw2[2]=Forwardw2[2]+deltaS2W2\n\n                deltaS2W3=lc*ForwardError2*X3\n                Forwardw2[3]=Forwardw2[3]+deltaS2W3\n                \n\n\n\n            elif(direction == \"left\"):\n                deltaS1W0=lc*LeftError1\n                Leftw1[0]=Leftw1[0]+deltaS1W0\n                \n                deltaS1W1=lc*LeftError1*X1\n                Leftw1[1]=Leftw1[1]+deltaS1W1\n\n                deltaS1W2=lc*LeftError1*X2\n                Leftw1[2]=Leftw1[2]+deltaS1W2\n\n                deltaS1W3=lc*LeftError1*X3\n                Leftw1[3]=Leftw1[3]+deltaS1W3\n\n                deltaS2W0 = lc*LeftError2\n                Leftw2[0] = Leftw2[0]+deltaS2W0\n\n                deltaS2W1=lc*LeftError2*X1\n                Leftw2[1]=Leftw2[1]+deltaS2W1\n\n                deltaS2W2=lc*LeftError2*X2\n                Leftw2[2]=Leftw2[2]+deltaS2W2\n\n                deltaS2W3=lc*LeftError2*X3\n                Leftw2[3]=Leftw2[3]+deltaS2W3\n            \n            elif(direction == \"right\"):\n                deltaS1W0=lc*RightError1\n                Rightw1[0]=Rightw1[0]+deltaS1W0\n                \n                deltaS1W1=lc*RightError1*X1\n                Rightw1[1]=Rightw1[1]+deltaS1W1\n\n                deltaS1W2=lc*RightError1*X2\n                Rightw1[2]=Rightw1[2]+deltaS1W2\n\n                deltaS1W3=lc*RightError1*X3\n                Rightw1[3]=Rightw1[3]+deltaS1W3\n\n                deltaS2W0 = lc*RightError2\n                Rightw2[0] = Rightw2[0]+deltaS2W0\n\n                deltaS2W1=lc*RightError2*X1\n                Rightw2[1]=Rightw2[1]+deltaS2W1\n\n                deltaS2W2=lc*RightError2*X2\n                Rightw2[2]=Rightw2[2]+deltaS2W2\n\n                deltaS2W3=lc*RightError2*X3\n                Rightw2[3]=Rightw2[3]+deltaS2W3\n            \n            elif(direction == \"reverse\"):\n                deltaS1W0=lc*ReverseError1\n                Reversew1[0]=Reversew1[0]+deltaS1W0\n                \n                deltaS1W1=lc*ReverseError1*X1\n                Reversew1[1]=Reversew1[1]+deltaS1W1\n\n                deltaS1W2=lc*ReverseError1*X2\n                Reversew1[2]=Reversew1[2]+deltaS1W2\n\n                deltaS1W3=lc*ReverseError1*X3\n                Reversew1[3]=Reversew1[3]+deltaS1W3\n\n                deltaS2W0 = lc*ReverseError2\n                Reversew2[0] = Reversew2[0]+deltaS2W0\n\n                deltaS2W1=lc*ReverseError2*X1\n                Reversew2[1]=Reversew2[1]+deltaS2W1\n\n                deltaS2W2=lc*ReverseError2*X2\n                Reversew2[2]=Reversew2[2]+deltaS2W2\n\n                deltaS2W3=lc*ReverseError2*X3\n                Reversew2[3]=Reversew2[3]+deltaS2W3\n        \n\n\n        if(myVariable > 20000):\n\n            if out1 == 0 and out2 == 0:\n                drivetrain.drive_for(REVERSE, 30, MM)\n                drivetrain.turn_for(LEFT, 15, DEGREES)\n            if out1 == 0 and out2 == 1:\n                drivetrain.turn_for(LEFT, 5, DEGREES)\n            if out1 == 1 and out2 == 0:\n                drivetrain.turn_for(RIGHT, 5, DEGREES)\n            if out1 == 1 and out2 == 1:\n                drivetrain.drive_for(FORWARD, 20, MM)\n\n        myVariable = myVariable + 1\n\n        # for i in range(4):\n        #     brain.print('\\n' , [i+ 1] , Forwardw1[i] , ', ' , Leftw1[i], ', ' , Rightw1[i], ', ' , Reversew1[i])\n        wait(5, MSEC)\n#end \n\nvr_thread(initialWeightSetup())\nvr_thread(when_started1())\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"","appVersion":"","fileFormat":"1.0.0","icon":"","playground":"WallMaze"}